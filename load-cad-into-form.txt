using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using Newtonsoft.Json;
using System.IO;

namespace MyProvip
{
    public class DrawingEntity
    {
        public string LocalName { get; set; }
        public string Type { get; set; }
        public string Text { get; set; }
        public double xP1 { get; set; }
        public double yP1 { get; set; }
        public double xP2 { get; set; }
        public double yP2 { get; set; }
        public double xCenter { get; set; }
        public double yCenter { get; set; }
        public double rotation { get; set; }
        public double Radius { get; set; }
        public double StartAngle { get; set; }
        public double EndAngle { get; set; }
        public bool IsClosedPolyline { get; set; }
        public List<DrawingEntity> SubEntities { get; set; } = new List<DrawingEntity>();
        public List<VertexPoint> Vertices { get; set; }
    }

    public class VertexPoint
    {
        public double X { get; set; }
        public double Y { get; set; }
    }

    public class RootData
    {
        public List<Dictionary<string, Dictionary<string, List<DrawingEntity>>>> Branches { get; set; }
        public List<DrawingEntity> Equipments { get; set; }
        public List<DrawingEntity> InstrumentLines { get; set; }
    }

    public partial class ManualElementForm : Form
    {
        private List<DrawingEntity> allEntities = new List<DrawingEntity>();
        private DrawingEntity selectedEntity = null;

        // transform
        private float scale = 1.0f;
        private float offsetX = 0;
        private float offsetY = 0;

        // insert mode
        private bool insertMode = false;
        private string currentInsertType = "Line";

        private Panel drawingPanel;

        public ManualElementForm()
        {
            InitializeComponent();

            // Create main panel
            drawingPanel = new Panel
            {
                Dock = DockStyle.Fill,
                BackColor = Color.White
            };

            // Create toolbar
            Panel toolbar = CreateToolbar();
            
            this.Controls.Add(drawingPanel);
            this.Controls.Add(toolbar);

            drawingPanel.Paint += Panel1_Paint;
            drawingPanel.MouseClick += Panel1_MouseClick;
            drawingPanel.MouseWheel += Panel1_MouseWheel;

            // Example: Load JSON file
            // string jsonPath = @"C:\path\to\your\drawing.json";
            // LoadFromJson(jsonPath);
        }

        private Panel CreateToolbar()
        {
            Panel toolbar = new Panel
            {
                Dock = DockStyle.Top,
                Height = 50,
                BackColor = Color.LightGray
            };

            Button btnLoadJson = new Button
            {
                Text = "Load JSON",
                Location = new Point(10, 10),
                Size = new Size(80, 30)
            };
            btnLoadJson.Click += BtnLoadJson_Click;

            Button btnSaveJson = new Button
            {
                Text = "Save JSON",
                Location = new Point(100, 10),
                Size = new Size(80, 30)
            };
            btnSaveJson.Click += BtnSaveJson_Click;

            Button btnInsertLine = new Button
            {
                Text = "Insert Line",
                Location = new Point(190, 10),
                Size = new Size(80, 30)
            };
            btnInsertLine.Click += (s, e) => SetInsertMode("Line");

            Button btnInsertCircle = new Button
            {
                Text = "Insert Circle",
                Location = new Point(280, 10),
                Size = new Size(80, 30)
            };
            btnInsertCircle.Click += (s, e) => SetInsertMode("Circle");

            Button btnInsertValve = new Button
            {
                Text = "Insert Valve",
                Location = new Point(370, 10),
                Size = new Size(80, 30)
            };
            btnInsertValve.Click += (s, e) => SetInsertMode("Valve");

            Button btnSelect = new Button
            {
                Text = "Select",
                Location = new Point(460, 10),
                Size = new Size(80, 30)
            };
            btnSelect.Click += (s, e) => SetInsertMode("Select");

            Button btnDelete = new Button
            {
                Text = "Delete",
                Location = new Point(550, 10),
                Size = new Size(80, 30)
            };
            btnDelete.Click += BtnDelete_Click;

            toolbar.Controls.AddRange(new Control[] { 
                btnLoadJson, btnSaveJson, btnInsertLine, btnInsertCircle, 
                btnInsertValve, btnSelect, btnDelete 
            });

            return toolbar;
        }

        private void SetInsertMode(string mode)
        {
            if (mode == "Select")
            {
                insertMode = false;
                this.Cursor = Cursors.Default;
            }
            else
            {
                insertMode = true;
                currentInsertType = mode;
                this.Cursor = Cursors.Cross;
            }
        }

        private void BtnLoadJson_Click(object sender, EventArgs e)
        {
            using (OpenFileDialog ofd = new OpenFileDialog())
            {
                ofd.Filter = "JSON Files|*.json|All Files|*.*";
                if (ofd.ShowDialog() == DialogResult.OK)
                {
                    LoadFromJson(ofd.FileName);
                }
            }
        }

        private void BtnSaveJson_Click(object sender, EventArgs e)
        {
            using (SaveFileDialog sfd = new SaveFileDialog())
            {
                sfd.Filter = "JSON Files|*.json|All Files|*.*";
                if (sfd.ShowDialog() == DialogResult.OK)
                {
                    SaveToJson(sfd.FileName);
                }
            }
        }

        private void BtnDelete_Click(object sender, EventArgs e)
        {
            if (selectedEntity != null)
            {
                RemoveEntityRecursive(selectedEntity);
                selectedEntity = null;
                drawingPanel.Invalidate();
            }
        }

        private void RemoveEntityRecursive(DrawingEntity entity)
        {
            allEntities.Remove(entity);
            
            // Also remove from any parent's SubEntities
            foreach (var parent in allEntities.Where(e => e.SubEntities.Contains(entity)))
            {
                parent.SubEntities.Remove(entity);
            }
        }

        private void LoadFromJson(string path)
        {
            try
            {
                string jsonContent = File.ReadAllText(path);
                var rootData = JsonConvert.DeserializeObject<RootData>(jsonContent);
                
                allEntities.Clear();
                
                // Load Branches
                if (rootData.Branches != null)
                {
                    foreach (var branchGroup in rootData.Branches)
                    {
                        foreach (var pipelineGroup in branchGroup)
                        {
                            foreach (var branch in pipelineGroup.Value)
                            {
                                foreach (var entity in branch.Value)
                                {
                                    allEntities.Add(entity);
                                    // Add sub-entities as well
                                    if (entity.SubEntities != null)
                                    {
                                        AddSubEntitiesRecursive(entity.SubEntities);
                                    }
                                }
                            }
                        }
                    }
                }

                // Load Equipments
                if (rootData.Equipments != null)
                {
                    foreach (var equipment in rootData.Equipments)
                    {
                        allEntities.Add(equipment);
                        if (equipment.SubEntities != null)
                        {
                            AddSubEntitiesRecursive(equipment.SubEntities);
                        }
                    }
                }

                // Load InstrumentLines
                if (rootData.InstrumentLines != null)
                {
                    foreach (var instrumentLine in rootData.InstrumentLines)
                    {
                        allEntities.Add(instrumentLine);
                        if (instrumentLine.SubEntities != null)
                        {
                            AddSubEntitiesRecursive(instrumentLine.SubEntities);
                        }
                    }
                }

                FitToScreen();
                drawingPanel.Invalidate();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error loading JSON file: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void AddSubEntitiesRecursive(List<DrawingEntity> subEntities)
        {
            foreach (var subEntity in subEntities)
            {
                allEntities.Add(subEntity);
                if (subEntity.SubEntities != null && subEntity.SubEntities.Count > 0)
                {
                    AddSubEntitiesRecursive(subEntity.SubEntities);
                }
            }
        }

        private void SaveToJson(string path)
        {
            try
            {
                // Group entities back into the new structure
                var rootData = new RootData
                {
                    Branches = new List<Dictionary<string, Dictionary<string, List<DrawingEntity>>>>(),
                    Equipments = new List<DrawingEntity>(),
                    InstrumentLines = new List<DrawingEntity>()
                };

                // Simple grouping - classify entities by their type or LocalName
                foreach (var entity in allEntities.Where(e => e.SubEntities == null || e.SubEntities.Count == 0))
                {
                    if (entity.Type == "Valve" || entity.LocalName.StartsWith("b_"))
                    {
                        // Add to branches
                        var defaultBranch = new Dictionary<string, Dictionary<string, List<DrawingEntity>>>();
                        var branchData = new Dictionary<string, List<DrawingEntity>>
                        {
                            { "SCBRAN 1", new List<DrawingEntity> { entity } }
                        };
                        defaultBranch["Default Pipeline"] = branchData;
                        rootData.Branches.Add(defaultBranch);
                    }
                    else if (entity.LocalName.StartsWith("e_") || entity.Type == "Equipment")
                    {
                        rootData.Equipments.Add(entity);
                    }
                    else if (entity.LocalName.StartsWith("i_") || entity.Type == "InstrumentLine")
                    {
                        rootData.InstrumentLines.Add(entity);
                    }
                    else
                    {
                        // Default to branches for lines and other basic entities
                        var defaultBranch = new Dictionary<string, Dictionary<string, List<DrawingEntity>>>();
                        var branchData = new Dictionary<string, List<DrawingEntity>>
                        {
                            { "SCBRAN 1", new List<DrawingEntity> { entity } }
                        };
                        defaultBranch["Default Pipeline"] = branchData;
                        rootData.Branches.Add(defaultBranch);
                    }
                }

                var jsonContent = JsonConvert.SerializeObject(rootData, Formatting.Indented);
                File.WriteAllText(path, jsonContent);
                
                MessageBox.Show("File saved successfully!", "Success", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error saving JSON file: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void FitToScreen()
        {
            if (allEntities.Count == 0) 
            {
                scale = 1.0f;
                offsetX = 0;
                offsetY = 0;
                return;
            }

            double minX = allEntities.Min(e => GetEntityMinX(e));
            double minY = allEntities.Min(e => GetEntityMinY(e));
            double maxX = allEntities.Max(e => GetEntityMaxX(e));
            double maxY = allEntities.Max(e => GetEntityMaxY(e));

            var dx = maxX - minX;
            var dy = maxY - minY;

            if (dx == 0) dx = 1;
            if (dy == 0) dy = 1;

            var sx = drawingPanel.Width / (float)dx;
            var sy = drawingPanel.Height / (float)dy;
            scale = Math.Min(sx, sy) * 0.8f; // Giảm xuống 0.8 để có margin

            // Center the drawing
            var centerX = (minX + maxX) / 2;
            var centerY = (minY + maxY) / 2;
            
            offsetX = (float)(drawingPanel.Width / (2 * scale) - centerX);
            offsetY = (float)(drawingPanel.Height / (2 * scale) - centerY);
        }

        private double GetEntityMinX(DrawingEntity e)
        {
            switch (e.Type)
            {
                case "Line":
                    return Math.Min(e.xP1, e.xP2);
                case "Circle":
                    return e.xCenter - e.Radius;
                case "Arc":
                    return e.xCenter - e.Radius;
                case "Polyline":
                    return e.Vertices?.Min(v => v.X) ?? e.xCenter;
                case "Valve":
                    return e.xCenter - 10; // Estimate valve size
                default:
                    return e.xCenter;
            }
        }

        private double GetEntityMinY(DrawingEntity e)
        {
            switch (e.Type)
            {
                case "Line":
                    return Math.Min(e.yP1, e.yP2);
                case "Circle":
                    return e.yCenter - e.Radius;
                case "Arc":
                    return e.yCenter - e.Radius;
                case "Polyline":
                    return e.Vertices?.Min(v => v.Y) ?? e.yCenter;
                case "Valve":
                    return e.yCenter - 10;
                default:
                    return e.yCenter;
            }
        }

        private double GetEntityMaxX(DrawingEntity e)
        {
            switch (e.Type)
            {
                case "Line":
                    return Math.Max(e.xP1, e.xP2);
                case "Circle":
                    return e.xCenter + e.Radius;
                case "Arc":
                    return e.xCenter + e.Radius;
                case "Polyline":
                    return e.Vertices?.Max(v => v.X) ?? e.xCenter;
                case "Valve":
                    return e.xCenter + 10;
                default:
                    return e.xCenter;
            }
        }

        private double GetEntityMaxY(DrawingEntity e)
        {
            switch (e.Type)
            {
                case "Line":
                    return Math.Max(e.yP1, e.yP2);
                case "Circle":
                    return e.yCenter + e.Radius;
                case "Arc":
                    return e.yCenter + e.Radius;
                case "Polyline":
                    return e.Vertices?.Max(v => v.Y) ?? e.yCenter;
                case "Valve":
                    return e.yCenter + 10;
                default:
                    return e.yCenter;
            }
        }

        private PointF WorldToScreen(double x, double y)
        {
            return new PointF(
                (float)((x + offsetX) * scale),
                drawingPanel.Height - (float)((y + offsetY) * scale)
            );
        }

        private PointF ScreenToWorld(PointF screenPoint)
        {
            double x = screenPoint.X / scale - offsetX;
            double y = (drawingPanel.Height - screenPoint.Y) / scale - offsetY;
            return new PointF((float)x, (float)y);
        }

        private void Panel1_Paint(object sender, PaintEventArgs e)
        {
            var g = e.Graphics;
            g.Clear(Color.White);

            foreach (var entity in allEntities)
            {
                DrawEntity(g, entity);
            }
        }

        private void DrawEntity(Graphics g, DrawingEntity entity)
        {
            Pen pen = (entity == selectedEntity) ? new Pen(Color.Red, 2) : new Pen(Color.Black, 1);
            Brush textBrush = Brushes.Blue;
            Font textFont = new Font("Arial", 8);

            switch (entity.Type)
            {
                case "Line":
                    var p1 = WorldToScreen(entity.xP1, entity.yP1);
                    var p2 = WorldToScreen(entity.xP2, entity.yP2);
                    g.DrawLine(pen, p1, p2);
                    break;

                case "Circle":
                    var center = WorldToScreen(entity.xCenter, entity.yCenter);
                    float r = (float)(entity.Radius * scale);
                    g.DrawEllipse(pen, center.X - r, center.Y - r, r * 2, r * 2);
                    break;

                case "Arc":
                    var ac = WorldToScreen(entity.xCenter, entity.yCenter);
                    float ra = (float)(entity.Radius * scale);
                    float start = (float)entity.StartAngle;
                    float sweep = (float)(entity.EndAngle - entity.StartAngle);
                    if (sweep <= 0) sweep += 360;
                    g.DrawArc(pen, ac.X - ra, ac.Y - ra, ra * 2, ra * 2, start, sweep);
                    break;

                case "Polyline":
                    if (entity.Vertices != null && entity.Vertices.Count > 1)
                    {
                        var pts = entity.Vertices.Select(v => WorldToScreen(v.X, v.Y)).ToArray();
                        if (entity.IsClosedPolyline)
                            g.DrawPolygon(pen, pts);
                        else
                            g.DrawLines(pen, pts);
                    }
                    break;

                case "Valve":
                    // Draw valve as a rectangle with text
                    var valveCenter = WorldToScreen(entity.xCenter, entity.yCenter);
                    float valveSize = 20 * scale;
                    
                    // Apply rotation if needed
                    g.TranslateTransform(valveCenter.X, valveCenter.Y);
                    g.RotateTransform((float)entity.rotation);
                    
                    g.DrawRectangle(pen, -valveSize/2, -valveSize/2, valveSize, valveSize);
                    
                    // Draw text if exists
                    if (!string.IsNullOrEmpty(entity.Text))
                    {
                        var textSize = g.MeasureString(entity.Text, textFont);
                        g.DrawString(entity.Text, textFont, textBrush, -textSize.Width/2, valveSize/2 + 5);
                    }
                    
                    g.ResetTransform();
                    
                    // Draw sub-entities
                    if (entity.SubEntities != null)
                    {
                        foreach (var subEntity in entity.SubEntities)
                        {
                            DrawEntity(g, subEntity);
                        }
                    }
                    break;
            }

            pen.Dispose();
        }

        private void Panel1_MouseClick(object sender, MouseEventArgs e)
        {
            if (insertMode)
            {
                HandleInsertClick(e.Location);
            }
            else
            {
                HandleSelectClick(e.Location);
            }
        }

        private void HandleInsertClick(PointF location)
        {
            var worldPos = ScreenToWorld(location);

            switch (currentInsertType)
            {
                case "Line":
                    InsertLine(worldPos);
                    break;
                case "Circle":
                    InsertCircle(worldPos);
                    break;
                case "Valve":
                    InsertValve(worldPos);
                    break;
            }
        }

        private void InsertLine(PointF startPos)
        {
            var line = new DrawingEntity
            {
                LocalName = $"l_{DateTime.Now.Ticks}",
                Type = "Line",
                xP1 = startPos.X,
                yP1 = startPos.Y,
                xP2 = startPos.X + 50,
                yP2 = startPos.Y
            };
            
            allEntities.Add(line);
            drawingPanel.Invalidate();
        }

        private void InsertCircle(PointF centerPos)
        {
            var circle = new DrawingEntity
            {
                LocalName = $"c_{DateTime.Now.Ticks}",
                Type = "Circle",
                xCenter = centerPos.X,
                yCenter = centerPos.Y,
                Radius = 25
            };
            
            allEntities.Add(circle);
            drawingPanel.Invalidate();
        }

        private void InsertValve(PointF centerPos)
        {
            var valve = new DrawingEntity
            {
                LocalName = $"v_{DateTime.Now.Ticks}",
                Type = "Valve",
                Text = "NEW-VALVE",
                xCenter = centerPos.X,
                yCenter = centerPos.Y,
                rotation = 0,
                SubEntities = new List<DrawingEntity>
                {
                    new DrawingEntity
                    {
                        LocalName = $"v_{DateTime.Now.Ticks}_circle",
                        Type = "Circle",
                        xCenter = centerPos.X,
                        yCenter = centerPos.Y,
                        Radius = 5
                    }
                }
            };
            
            allEntities.Add(valve);
            // Add sub-entities to main list for selection
            AddSubEntitiesRecursive(valve.SubEntities);
            drawingPanel.Invalidate();
        }

        private void HandleSelectClick(PointF location)
        {
            const double tolerance = 10.0;
            selectedEntity = null;

            foreach (var entity in allEntities)
            {
                if (IsEntityClicked(entity, location, tolerance))
                {
                    selectedEntity = entity;
                    break;
                }
            }
            
            drawingPanel.Invalidate();
        }

        private bool IsEntityClicked(DrawingEntity entity, PointF location, double tolerance)
        {
            switch (entity.Type)
            {
                case "Line":
                    var p1 = WorldToScreen(entity.xP1, entity.yP1);
                    var p2 = WorldToScreen(entity.xP2, entity.yP2);
                    return PointToLineDistance(location, p1, p2) < tolerance;

                case "Circle":
                    var center = WorldToScreen(entity.xCenter, entity.yCenter);
                    float r = (float)(entity.Radius * scale);
                    var dist = Distance(location, center);
                    return Math.Abs(dist - r) < tolerance;

                case "Valve":
                    var valveCenter = WorldToScreen(entity.xCenter, entity.yCenter);
                    return Distance(location, valveCenter) < tolerance;

                case "Polyline":
                    if (entity.Vertices != null && entity.Vertices.Count > 1)
                    {
                        for (int i = 0; i < entity.Vertices.Count - 1; i++)
                        {
                            var pt1 = WorldToScreen(entity.Vertices[i].X, entity.Vertices[i].Y);
                            var pt2 = WorldToScreen(entity.Vertices[i + 1].X, entity.Vertices[i + 1].Y);
                            if (PointToLineDistance(location, pt1, pt2) < tolerance)
                                return true;
                        }
                    }
                    return false;

                default:
                    return false;
            }
        }

        private double Distance(PointF p1, PointF p2)
        {
            double dx = p1.X - p2.X;
            double dy = p1.Y - p2.Y;
            return Math.Sqrt(dx * dx + dy * dy);
        }

        private double PointToLineDistance(PointF p, PointF a, PointF b)
        {
            double A = p.X - a.X;
            double B = p.Y - a.Y;
            double C = b.X - a.X;
            double D = b.Y - a.Y;

            double dot = A * C + B * D;
            double lenSq = C * C + D * D;
            double param = (lenSq != 0) ? dot / lenSq : -1;

            double xx, yy;
            if (param < 0) { xx = a.X; yy = a.Y; }
            else if (param > 1) { xx = b.X; yy = b.Y; }
            else { xx = a.X + param * C; yy = a.Y + param * D; }

            double dx = p.X - xx;
            double dy = p.Y - yy;
            return Math.Sqrt(dx * dx + dy * dy);
        }

        private void Panel1_MouseWheel(object sender, MouseEventArgs e)
        {
            // Get mouse position in world coordinates before zoom
            var worldPosBefore = ScreenToWorld(e.Location);
            
            // Apply zoom
            float oldScale = scale;
            if (e.Delta > 0) 
                scale *= 1.1f;
            else 
                scale *= 0.9f;
            
            // Get mouse position in world coordinates after zoom
            var worldPosAfter = ScreenToWorld(e.Location);
            
            // Adjust offset to keep mouse position stable
            offsetX += (float)(worldPosAfter.X - worldPosBefore.X);
            offsetY += (float)(worldPosAfter.Y - worldPosBefore.Y);
            
            drawingPanel.Invalidate();
        }
    }
}